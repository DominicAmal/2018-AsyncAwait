<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Async functions in practice</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/sky.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/tomorrow.css">

    <link rel="stylesheet" href="plugin/line-numbers/line-numbers.css">

    <!-- My own customizations -->
    <style>
      .reveal pre code {
        padding: 1em;
      }
      .reveal mark {
        background-color: #ffcccc;
      }
      .reveal li {
        margin: 0.5em 0;
      }

      .reveal .attribution {
        position: fixed;
        bottom: 0px;
        width: 90%;
        font-size: 0.4em;
        font-style: italic;
      }

      .reveal .ok:before {
        color: green;
        content: "\2713\00a0";
      }

      .reveal .notok:before {
        color: red;
        content: "\2717\00a0";
      }

      .reveal .note {
        font-size: 0.8em;
        font-style: italic;
      }

      ul.nodisc {
        list-style-type: none;
      }

      code span.highlight-line:before {
        color: #4d4d4c !important;
        font-weight: bold;
      }

      code.nohighlight {
        background-color: white;
      }
    </style>

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
<!-- ======= SLIDES START ======= -->

<section>
  <br/>
  <h2>Async functions<br/>in practice</h2>
  <h4><em>
    tips, tricks and caveats you want to know<br/>
    before migrating from callbacks
  </em></h4>
  <br/>
  <br/>
  <div style="text-align: right">Miroslav Bajto≈°</div>
</section>

  <!--
    My personal story.

    I started developing on Node.js platform when I joined StrongLoop
    in 2013, shortly after Node.js 0.10 was released and Node.js was all
    about callbacks and streams. ES6 was many years away, Promises were
    considered almost as a heresy and async/await was not even conceived
    (for JavaScript). The programming model wasn't great - it required
    a lot of ceremonies and made it easy to introduce subtle bugs,
    but over time I sort of got used to it.

    As ES6 was solidifying and work began on the future versions, people
    started to search for even better primitives for flow control.
    Around 2014, generator functions were the new star, I still remember
    a talk from NodeSummit 2014 where they explained how to implement
    async/await using generators. Crazy stuff!

    Now in LoopBack, we made a decision in January 2017 to rewrite the framework
    from scratch using TypeScript and latest language goodness including
    async/await.

    At that time, async/await was available in Node.js behind a feature
    flag and the performance was terrible. And by terrible I mean async/await
    was about ~6x slower than callbacks. I was not happy about that
    and wanted to better understand pros and cons of the new programming
    model. In the past two years, I was closely watching evolution of async
    functions and at the same time gaining hands-on experience by writing
    our new framework version using async/await.

    Today I am happy that my scepticism was overruled by other team members
    and our new codebase is using async functions everywhere. We are still
    maintaining our legacy code base from ES5 days and it's so less fun than
    ES2017!
  -->

<section>
  <h2>Agenda</h2>
  <ul>
    <li class="fragment"><code>async</code> and <code>await</code> are awesome!
    <li class="fragment">runtime &amp; ecosystem readiness
    <li class="fragment">tips, tricks and caveats
  </ul>
</section>

<section>
  <section>
    <h2><code>async &amp; await</code></h2>
    and its goodness
  </section>

  <section>
    <h3>Definition</h3>
    <p style="font-size: 0.8em">
    <div>An <em>async function</em> can contain an <em>await expression</em></div>
    <div class="fragment">that pauses the execution of the async function</div>
    <div class="fragment">and waits for the passed Promise's resolution,</div>
    <div class="fragment">and then resumes the async function's execution</div>
    <div class="fragment">and returns the resolved value.</div>
    <p class="note" style="text-align: right; padding-top: 2em">Source: <a
       href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">Mozilla web docs</a>
  </section>

  <section>
    <h3>Example</h3>
    <p>Async function
    <pre><code class="javascript line-numbers" data-trim data-noescape>
      async function run(){
        const response = await request('http://example.com/');
        console.log(response);
      }
    </code></pre>
    <div class="fragment">
    <p>Callbacks
    <pre><code class="javascript line-numbers" data-trim>
      function run(callback){
        request('http://example.com/', (error, response) => {
          if (error) return callback(error);
          console.log(response);
          callback();
        });
      }
    </code></pre>
    </div>
  </section>

  <section>
    <h3>Cleaner code</h3>
  </section>

  <!--
    PROBLEM: people forget to add code to handle errors,
    the algorithm runs as if all was good and crashed later
    with an error difficult to understand (often on access to "undefined")

    Nested function and callback hell/Christmas tree.

    Our legacy codebase is full of code like this.
  -->
  <section><pre><code class="javascript" data-trim data-noescape>
  it('creates a product in a category', (done) =&gt; {
    Category.create({name: 'Food'}, (err, cat) =&gt; {
      <mark class="fragment">if (err) return done(err);</mark>

      cat.products.create({name: 'Apple'}, (err, prod) =&gt; {
        <mark class="fragment"> if (err) return done(err);</mark>

        expect(prod).to.have.property('categoryId', cat.id);
        done();
      });
    });
  });
  </code></pre></section>

  <!--
    SOLUTION: await enables imperative/sync-like code and propagates errors
  -->
  <section><pre><code class="javascript" data-trim data-noescape>
  it('creates a product in a category', <mark>async ()</mark> =&gt; {
    const cat = <mark>await</mark> Category.create({name: 'Food'});
    const prod = <mark>await</mark> cat.products.create({name: 'Apple'});
    expect(prod).to.have.property('categoryId', cat.id);
  });
  </code></pre></section>

  <!-- PROBLEM: how to interact with existing code (callbacks/promises)? -->
  <section>
    <h3>It works great with Promises!</h3>
  </section>

  <section>
    <h3>Consume Promises</h3>
    <pre><code class="javascript" data-trim data-noescape>
    function sleep(ms) {
      return new Promise((resolve, reject) => {
        setTimeout(resolve, ms);
      });
    }
    </code></pre>
    <pre class="fragment"><code class="javascript" data-trim data-noescape>
    await sleep(100);
    </code></pre>
  </section>

  <section>
    <h3>Produce Promises</h3>
    <pre><code class="javascript" data-trim data-noescape>
    async function step() {
      console.log('raise your foot');
      await sleep(100);
      console.log('lower your foot');
      return 'made a step';
    }
    </code></pre>
    <pre class="fragment"><code class="javascript" data-trim data-noescape>
    step().then(result => console.log(result));
    </code></pre>
  </section>

  <!-- A PERK: troubleshooting is so much easier -->
  <section>
    <h3>Better error stack traces</h3>
  </section>

  <section>
    <p>Callbacks
    <pre><code class="javascript line-numbers" data-trim data-noescape data-highlight-lines="5">
    function step(cb) { process.nextTick(cb); }

    function walk(cb) {
      return step(err =&gt; {
        cb(new Error('too tired'));
      });
    }
    </code></pre>
    <pre class="fragment"><code class="nohighlight" data-trim data-noescape>
    Error: too tired
        <mark>at step</mark> (walk-callback.js:5:8)
        at process._tickCallback (next_tick.js:61:11)
    </code></pre>
  </section>

  <section>
    <p>Promises
    <pre><code class="javascript line-numbers" data-trim data-noescape data-highlight-lines="5">
    function step() { return Promise.resolve(); }

    function walk() {
      return step().then(() =&gt; {
        throw new Error('too tired');
      });
    }
    </code></pre>
    <pre class="fragment"><code class="nohighlight" data-trim data-noescape>
    Error: too tired
        <mark>at step.then</mark> (walk-promise.js:5:11)
        at process._tickCallback (next_tick.js:68:7)
    </code></pre>
  </section>

  <section>
    <p>Async &amp; await
    <pre><code class="javascript line-numbers" data-trim data-noescape data-highlight-lines="5">
    async function step() {}

    async function walk() {
      await step();
      throw new Error('too tired');
    }
    </code></pre>
    <pre class="fragment"><code class="nohighlight" data-trim data-noescape>
    Error: too tired
        <mark>at walk</mark> (walk-async.js:5:9)
        at process._tickCallback (next_tick.js:68:7)
    </code></pre>
  </section>

  <section>
    <h3>The debugger</h3>
    <p>F10 steps over await statements
  </section>
</section>

<!-- OK, async/await is so promising. But is ready for use? -->

<section>
  <section>
    <h2>Implementation status</h2>
  </section>

  <section>
    <h3>The language</h3>
    <p>ES2017
    <p class="note">(January 2017)
  </section>

  <section>
    <h3>The runtime</h3>
    <p>Node.js 8.9.0 LTS
    <p class="note">(October 2017)
  </section>

  <section>
    <h3>Node.js core API</h3>
    <img
         src="./img/under-construction.png"
         alt="work in progres"
         style="border:none; background: none; box-shadow: none;"
         height="150"
    />
    <p><em>(see <a
       href="https://github.com/nodejs/node/issues/15413">nodejs/node#15413)</a></em>
  </section>

  <section>
    <h3>Node.js&nbsp;&nbsp;8&nbsp;&nbsp;(LTS)</h3>
    <br/>
    <p><code>util.promisify()</code></p>
    <br/>
    <p>(more on this later)</p>
  </section>
  <section>
    <h3>Node.js&nbsp;&nbsp;10</h3>
    <p><em>Experimental API</em></p>
    <p><code>require('fs').promises</code></p>
    <p><code>require('dns').promises</code></p>
  </section>
</section>

<!--
  Most people don't use low-level core APIs but use higher-level libraries
  and frameworks. I am developing LoopBack, a framework for building API
  servers connecting to backend data sources. For me, it's important
  to write HTTP server, connect to HTTP services and different SQL/NoSQL
  databases. Let's take a look at how easy it is to use async/await there.
-->
<section>
  <section>
    <h2>Ecosystem readiness</h2>
  </section>

  <section>
    <h3>Server frameworks</h3>
    <ul class="nodisc">
      <li class="notok"><a href="https://www.npmjs.com/package/express">Express</a>
        <span class="note">(but see <a href="https://www.npmjs.com/package/express-promise-router">express-promise-router</a></span>)
      <li class="ok"><a href="https://www.npmjs.com/package/loopback">LoopBack</a>
        <span class="note">(REST API layer)</span>
      <li class="ok"><a href="https://www.npmjs.com/package/hapi">Hapi</a>
      <li class="ok"><a href="https://www.npmjs.com/package/koa">Koa</a>
      <li class="ok"><a href="https://www.npmjs.com/package/fastify">Fastify</a>
        <span class="note">(routes are async, middleware is callback-based.)</span>
      <li class="notok"><a href="https://www.npmjs.com/package/restify">Restify</a>
        <span class="note">(but see <a href="https://www.npmjs.com/package/restify-await-promise">restify-await-promise</a></span>)
    </ul>
  </section>


  <section>
    <h3>HTTP clients</h3>
    <ul class="nodisc">
      <li class="notok"><a href="https://www.npmjs.com/package/request">request</a>
        <span class="note">(but see <a href="https://www.npmjs.com/package/request-promise-native">request-promise-native</a>)</span>
      <li class="ok"><a href="https://www.npmjs.com/package/superagent">superagent</a>
      <li class="ok"><a href="https://www.npmjs.com/package/node-fetch">node-fetch</a>
      <li class="ok"><a href="https://www.npmjs.com/package/swagger-client">swagger-client</a>
    </ul>
  </section>

  <section>
    <h3>ORMs</h3>
    <ul class="nodisc">
      <li class="ok"><a href="https://www.npmjs.com/package/loopback">LoopBack</a>
        <span class ="note">(ORM layer)</span>
      <li class="ok"><a href="https://www.npmjs.com/package/knex">Knex</a>
      <li class="ok"><a href="https://www.npmjs.com/package/bookshelf">Bookshelf</a>
      <li class="ok"><a href="https://www.npmjs.com/package/sequelize">Sequelize</a>
      <li class="ok"><a href="https://www.npmjs.com/package/objection">Objection</a>
      <li class="ok"><a href="https://www.npmjs.com/package/mongoose">Mongoose</a>
    </ul>
  </section>

  <section>
    <h3>Database clients</h3>
    <ul class="nodisc">
      <li class="ok"><a href="https://www.npmjs.com/package/mongodb">MongoDB</a>
      <li class="ok"><a href="https://www.npmjs.com/package/pg">pg (PostgreSQL)</a>
      <li class="notok"><a href="https://www.npmjs.com/package/mysql">MySQL</a>
        <span class ="note">(see 3rd party wrappers adding Promise support)</span>
      <li class="notok"><a href="https://www.npmjs.com/package/redis">Redis</a>
      <li class="ok"><a href="https://www.npmjs.com/package/ioredis">ioredis</a>
    </ul>
  </section>
</section>

<!--
  Functional parity and ease of use would not be enough if the performance
  was terrible. Let's talk about performance for a bit.
-->

<section>
  <section>
    <h2>Performance</h2>
    <!--
    Bluebird has demonstrated that Promises can be fast,
      the V8 team has made a ton of work to speed up the built-in Promise
      implementation, and async/await enabled advanced optimizations that
      were not possible for callbacks or pure Promises. Where are we today?
    -->
  </section>

  <section>
    <h3>Microbenchmark</h3>
    <!--
      This is a slightly modified Doxbee benchmark from Bluebird.
      Critics say the benchmark is too biased towards making Bluebird look
      good, but I think every benchmark is biased and this one is good enough
      to get a basic comparison.
    -->
    <canvas data-chart="horizontalBar">
      <!--
        {
          "data": {
            "labels": [
              "callbacks",
              "Bluebird",
              "await Bluebird",
              "util.promisify",
              "await util.promisify"
            ],
            "datasets": [{
              "label": "time to complete (ms) - smaller is better",
              "data": [161, 273, 259, 341, 330],
              "backgroundColor": [
                "rgba(54, 162, 235, 0.6)",
                "rgba(183, 128, 162, 0.6)",
                "rgba(162, 183, 128, 0.6)",
                "rgba(183, 128, 162, 0.6)",
                "rgba(162, 183, 128, 0.6)"
              ]
            }]
          },
          "options": {
            "scales": {
              "xAxes":[{"ticks":{"beginAtZero":true}}]
            }
          }
        }
      -->
    </canvas>
    <p class="note"><a href="https://github.com/strongloop-forks/bluebird/tree/async/await">https://github.com/strongloop-forks/bluebird/tree/async/await</a>
  </section>

  <!--
    This benchmark is using `util.promisify` to convert core APIs to
    promise-enabled functions. I mentioned that Node.js 10.x is bringing
    experimental implementation of Promise-compatible APIs. Can they
    perform any better?
  -->

  <section>
    <h3>Promisified core APIs</h3>
    <canvas data-chart="horizontalBar">
      <!--
        {
          "data": {
            "labels": [
              "fstat (callback)",
              "fstat (fs.promise)",
              "lstat (callback)",
              "lstat (fs.promise)",
              "stat (callback)",
              "stat (fs.promise)"
            ],
            "datasets": [{
              "label": "time to complete (ms) - smaller is better",
              "data": [0.315, 0.295, 0.272, 0.256, 0.262, 0.253],
              "backgroundColor": [
                "rgba(54, 162, 235, 0.6)",
                "rgba(162, 183, 128, 0.6)",
                "rgba(54, 162, 235, 0.6)",
                "rgba(162, 183, 128, 0.6)",
                "rgba(54, 162, 235, 0.6)",
                "rgba(162, 183, 128, 0.6)"
              ]
            }]
          },
          "options": {
            "scales": {
              "xAxes":[{"ticks":{"beginAtZero":true}}]
            }
          }
        }
      -->
    </canvas>
  </section>

  <!--
    Let's face the truth - microbenchmarks are of limited use to application
    developers, because most bottlenecks are not caused because of flow control
    style. To get a more realistic numbers, I created a simple HTTP server
    fetching few records from a MongoDB database and compared performance
    of different server frameworks.
  -->
  <section>
    <h3>A "real" app</h3>
    <!--
      It turns out that callback-based Express is the slowest one
      and async/await based Koa is less than 10% slower that Fastify.
    -->
    <canvas data-chart="horizontalBar">
      <!--
        {
          "data": {
            "labels": ["Hapi", "Fastify", "Koa+router", "Express"],
            "datasets": [{
              "label": "requests per second - higher is better",
              "data": [5875, 7905, 7269, 5610],
              "backgroundColor": [
                "rgba(162, 183, 128, 0.6)",
                "rgba(54, 162, 235, 0.6)",
                "rgba(162, 183, 128, 0.6)",
                "rgba(54, 162, 235, 0.6)"
              ]
            }]
          },
          "options": {
            "scales": {
              "xAxes":[{"ticks":{"beginAtZero":true}}]
            }
          }
        }
      -->
    </canvas>
    <p class="note"><a href="https://github.com/bajtos/async-frameworks">https://github.com/bajtos/async-frameworks</a>
  </section>
</section>

<!--
  Now that I have hopefully convinced you that async/await is great and
  ready for use, let's look at practical aspects of writing async functions.
-->

<section>
  <section>
    <h2>Tips &amp; tricks</h2>
  </section>

  <section>
    <h3>Run tasks in parallel</h3>
    <!--
      `await` runs tasks in series
      use `Promise.all` for parallel execution
    -->
    <pre><code class="javascript" data-trim>
    const [walkResult, talkResult] = await Promise.all([
      walk(),
      talk(),
    ]);
    </code></pre>
  </section>

  <section>
    <h3>Await events</h3>
    <pre><code class="javascript" data-trim data-noescape>
    const http = require('http');
    <mark>const pEvent = require('p-event');</mark>

    async function start(handler) {
      const server = http.createServer(handler);
      server.listen(0);

      <mark>await pEvent(server, 'listen');</mark>
      return `http://localhost:${server.address().port}/`;
    }

    start(/*handler*/).then(
      url =&gt; console.log('Listening on:', url),
      <mark>err =&gt; console.log('Cannot start the server:', err)</mark>
    );
    </code></pre>
  </section>

  <section>
    <h3>Await callback-based functions</h3>
    <pre><code class="javascript" data-trim data-noescape>
    const util = require('util');
    const fs = require('fs');
    <mark>const readFile = util.promisify(fs.readFile);</mark>

    async function readData() {
      return await readFile('data.txt', 'utf-8');
    }
    </code></pre>
  </section>

  <section>
    <h3>Promisify classes</h3>
    <p>you are on your own :(
    <p><a href="https://www.npmjs.com/package/pifall">
      <code>pifall</code></a>
    <p><a href="https://www.npmjs.com/package/pify">
      <code>pify</code></a>
    <p><a href="http://bluebirdjs.com/docs/api/promise.promisifyall.html">
      <code>Bluebird.promisifyAll()</code></a>
  </section>


  <section>
    <h3>Multiple callback arguments</h3>
  </section>

  <section>
    <h4>Node.js core API</h4>
    <pre><code class="javascript" data-trim data-noescape>
    fs.read(fd, buffer, offset, len, pos,
      <mark>(err, bytesRead, buffer)</mark> =&gt; {
        // ...
      });

    const readAsync = util.promisify(fs.read);
    <mark>const {bytesRead, buffer} = await readAsync</mark>(fd, /*...*/pos);
    </code></pre>
  </section>

  <section>
    <h4>User-land API</h4>
    <p>you are own your own :(</p>
    <pre class="fragment"><code class="javascript" data-trim data-noescape>
    function whoami(callback) {
     callback(null, 'Miroslav', 'Bajtos');
    }

    function whoamiAsync() {
      return new Promise((resolve, reject) =&gt; {
        whoami(<mark>(err, name, surname)</mark> =&gt; {
          if (err) reject(err);
          else <mark>resolve({name, surname});</mark>
        });
      });
    };

    const {name, surname} = await whoamiAsync();
    </code></pre>
  </section>

  <section>
    <p>if you own the API
    <pre><code class="javascript" data-trim data-noescape>
    whoami[util.promisify.custom] = whoamiAsync;
    </code></pre>
    <p class="note">(see <a href="https://nodejs.org/dist/latest-v8.x/docs/api/util.html#util_custom_promisified_functions">
      Custom promisified functions</a> in Node.js docs)
  </section>

  <section>
    <h3>Async functions in<br/>callback-based code</h3>
  </section>
  <section>
    <p>Can you spot two problems?
    <pre><code class="javascript" data-trim>
    async function step() {
      return 'some data';
    }

    app.use((req, res, next) => {
      step()
        .then(next)
        .catch(next);
    });
    </code></pre>
  </section>
  <section>
    <p>The right way&trade;
    <pre><code class="javascript" data-trim>
    async function step() {
      return 'some data';
    }

    app.use((req, res, next) => {
      step().then(
        // onFulfilled
        success => process.nextTick(next),
        // onRejected
        error => process.nextTick(next, error)
      );
    });
    </code></pre>
  </section>

  <section>
    <h3>Stream Pipelines</h3>
    <pre><code class="javascript" data-trim>
    const pipeline = util.promisify(stream.pipeline);

    await pipeline(
      fs.createReadStream('archive.tar'),
      zlib.createGzip(),
      fs.createWriteStream('archive.tar.gz')
    );
    </code></pre>
    <p class="note">(requires Node.js 10.x)
  </section>

  <section>
    <h3>Streams as Async Iterators</h3>
    <pre><code class="javascript" data-trim data-noescape>
    const input = byline(
      fs.createReadStream(pathToFile, {encoding: 'utf-8'}))
    );

    for await (const line of input) {
      console.log(line);
    }
    </code></pre>
    <p class="note">(requires Node.js 10.x)
  </section>
</section>

<section>
  <section>
    <h2>Caveats</h2>
  </section>
  <section>
    <p><code>async</code> functions return a native promise
    <pre><code class="javascript" data-trim data-noescape>
    const Bluebird = require('bluebird');
    async function test() {
      return Bluebird.resolve(1);
    }

    <span class="fragment">console.log(test() instanceof Bluebird)</span>
    <span class="fragment">// false</span>

    <span class="fragment">
    console.log('spread' in test());
    // false
    </span>
    </code></pre>
  </section>
  <section>
    <h3><code>return await or not?</code></h3>
    <pre><code class="javascript" data-trim>
    async function getRepos() {
      const url = 'https://api.github.com/users/bajtos/repos';

      // GOOD: return the promise immediately
      return request(url);

      // NOT RECOMMENDED: await the result before returning
      return await request(url);
    }
    </code></pre>
    <p>avoid <a
      href="http://exploringjs.com/es2016-es2017/ch_async-functions.html#_returned-promises-are-not-wrapped">promise
      rewrapping</a>
  </section>
  <section>
    <h3>Unhandled errors</h3>
    <pre><code class="javascript" data-trim>
    async function tick() {
      throw new Error('BOOM!');
    }

    // missing await or then
    tick();
    </code></pre>
    <div class="fragment">
    <p>logs a warning, does not crash (yet)
    <p><a href="https://nodejs.org/dist/latest-v8.x/docs/api/process.html#process_event_unhandledrejection">
      <code>process.on('unhandledRejection')</code></a>
    </div>
  </section>
  <section>
    <h3>User-land Promise libraries</h3>
  </section>
  <section>
    <p>How to detect unhandled rejections?
  </section>
  <!--
  <section>
    <h3>Invalid API usage<br/>vs.<br/>operational errors</h3>
    <p>(see <a href="https://www.joyent.com/node-js/production/design/errors">Error Handling in Node.js</a>)
  </section>
  <section>
    <h4>Invalid API usage with a callback</h4>
    <pre><code class="javascript" data-trim>
    fs.readFile(undefined, console.log)
    </code></pre>
    <div class="fragment">
    <p>(process crashed)
    <pre><code class="nohighlight" data-trim>
    fs.js:358
      binding.open(pathModule._makeLong(path),
              ^

    TypeError: path must be a string or Buffer
        at Object.fs.readFile (fs.js:358:11)
        (...)
    </code></pre>
    </div>
  </section>
  <section>
    <h4>Operational error with a callback</h4>
    <pre><code class="javascript" data-trim>
    fs.readFile('unknown.txt', console.log)
    </code></pre>
    <div class="fragment">
    <p>(the process happily keeps running)
    <pre><code class="nohighlight" data-trim>
    { Error: ENOENT: no such file or directory, open 'unknown.txt'
      errno: -2,
      code: 'ENOENT',
      syscall: 'open',
      path: 'does-not-exist' }
    </code></pre>
    </div>
  </section>
  <section>
    <h4>Async functions always return<br/>a rejected promise</h4>
    <p class="note">(discussion: <a href="https://github.com/nodejs/promises/issues/10">nodejs/promises#10</a>)
  </section>
  <section>
    <h3>Post-mortem debugging</h3>
    <p><code>node -{FIXME}- abort-on-uncaught-exception</code>
    <p><em>(learn more: <a href="https://www.joyent.com/blog/post-mortem-debugging-and-promises">Post-mortem Debugging and Promises</a>)</em>
  </section>
  -->
</section>

<!--
<section>
  <section>
    <h2>Streams</h2>
    <p>(the future)
  </section>

  <section>
    <ul>
      <li>reading from streams
      <li>writing to streams
      <li>creating Readable streams
      <li>creating Writable streams
      <li>creating Transform streams
    </ul>
  </section>

  <section>
    <h3>Pipelines</h3>
    <pre><code class="javascript" data-trim>
    const pipeline = util.promisify(stream.pipeline);

    await pipeline(
      fs.createReadStream('archive.tar'),
      zlib.createGzip(),
      fs.createWriteStream('archive.tar.gz')
    );
    </code></pre>
    <p class="note">(requires Node.js 10.x)
  </section>

  <section>
    <h3>Streams as Async Iterators</h3>
    <pre><code class="javascript" data-trim data-noescape>
    const input = byline(
      fs.createReadStream(pathToFile, {encoding: 'utf-8'}))
    );

    for await (const line of input) {
      console.log(line);
    }
    </code></pre>
    <p class="note">(requires Node.js 10.x)
  </section>

  <section>
    <h4>Write to streams</h4>
    <p><em>(just dreaming)</em>
    <pre><code class="javascript" data-trim data-noescape>
    for await (const chunk of src) {
      await dest.write(chunk);
    }
    await dest.end();
    </code></pre>
    <p>backpressure!
  </section>
  <section>
    <h4>Create Readable streams</h4>
    <p><em>(just dreaming)</em>
    <pre><code class="javascript" data-trim data-noescape>
      new ReadableStream({
        async * _read() {
          for (const url of sourceUrls) {
            yield await fetch(url);
          }
        }
      });
    </code></pre>
  </section>
  <section>
    <h4>Create Writable streams</h4>
    <p><em>(just dreaming)</em>
    <pre><code class="javascript" data-trim data-noescape>
    new WritableStream({
      <mark>async write(chunk, encoding)</mark> {
        //...
      },
      <mark>async destroy()</mark> {
        // ...
      },
    });
    </code></pre>
    <p>backpressure!
  </section>
  <section>
    <h4>Create Transform streams</h4>
    <pre><code class="javascript" data-trim data-noescape>
    new TransformStream({
      buffer: '';
      <mark>async *transform(chunk, encoding)</mark> {
        buffer += chunk;
        const lines = /*await*/ buffer.split('\n');
        buffer = lines.pop();
        for (const l of lines) {
          yield l;
        }
      },
      <mark>async *flush()</mark> {
        yield buffer;
      },
    });
    </code></pre>
    <p>backpressure!
  </section>
  <section>
    <h4>And the rest?</h4>
    <p>The exact shape of the new Streams API in Node.js is not determined yet.
  </section>
</section>
-->

<section>
  <section>
  <h2>Migration guide</h2>
  </section>

  <section>
    <p>Complete rewrite is almost never
    <p>the right thing to do.
  </section>

  <section>
    <p>Keep delivering value to your clients.
  </section>

  <section>
    <p>Work incrementally.
    <p class="fragment">Focus on code that changes most often.
    <p class="fragment">Use your test suite to drive the priorities.
  </section>

  <section>
    <ol>
      <li>Go outside-in: API first, implementation second.
      <li class="fragment">Promisify internal APIs,<br/>preserve support for callbacks.
      <li class="fragment">Eventually replace callbacks with <code>await</code>
    </ol>
  </section>
</section>

<section>
  <section>
    <h2>Key takeaways</h2>
  </section>
  <section>
    <p>async functions are awesome
    <p>and ready to use
  </section>
  <section>
    <p>learn the new programming model
    <p class="note">(and its caveats)
  </section>
  <section>
    <p>upgrade your code base incrementally
  </section>
</section>

<section>
<br/>
<br/>
<h2>Thank you!</h2>
<br/>
<br/>
<p><em>Miroslav Bajto≈°</em>
<p><a href="https://github.com/bajtos">https://github.com/bajtos</a>
</section>


<!-- ======= SLIDES END ======= -->
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info about config & dependencies:
      // - https://github.com/hakimel/reveal.js#configuration
      // - https://github.com/hakimel/reveal.js#dependencies
      Reveal.initialize({
        pdfMaxPagesPerSlide: 1,

        progress: true,
        history: true,
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          {
            src: 'plugin/highlight/highlight.js',
            async: true,
            callback: function() { hljs.initHighlightingOnLoad(); }
          },
          { src: 'plugin/chart/Chart.min.js' },
          { src: 'plugin/chart/csv2chart.js' },
          { src: 'plugin/line-numbers/line-numbers.js'},
        ],
      });
    </script>
  </body>
</html>
